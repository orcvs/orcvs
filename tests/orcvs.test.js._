"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pattern = void 0;
// import { Pattern } from '../src/orcvs';
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
class Orcvs {
    constructor() {
        this.patterns = [];
    }
    bang(pattern, fn) {
        this.patterns.push(new Pattern(pattern, fn));
    }
    tick(f) {
        for (const pattern of this.patterns) {
            pattern.bang(f);
        }
    }
}
const Context = {
    lerp: (value) => {
        console.log('lerp');
        console.log(this);
    }
};
// Object.getOwnPropertyNames(this.context).forEach((key) => {
//   if (key !== 'constructor') {
//     this[key] = this[key].bind(this);
//   }
// });
class Pattern {
    constructor(str, fn) {
        this.context = Object.assign({}, Context);
        this.ptn = [...str];
        // this.fn = fn; //.bind(Context);
        this.fn = function () {
            var lerp = this.context.lerp;
            this.fn.lerp = this.context.lerp;
            fn.call(this);
        };
        // this.fn.lerp = this.context.lerp;       
    }
    shouldBang(f) {
        const idx = f % this.ptn.length;
        return this.ptn[idx] === '!';
    }
    bang(f) {
        // console.log('patterns.bang', { f });
        // console.log('patterns.bang', this.fn);
        // console.log('patterns.bang', this.shouldBang(f));
        // if (this.fn) {  
        console.log('Pattern.bang', this.fn);
        // if (this.shouldBang(f)) {  
        // (() => {
        // var lerp = this.context.lerp
        // var lerp = this.context.lerp;
        // this.fn.call(this.context);
        this.fn();
        // })()
        // this.fn.call(Context);
        // }      
        // }    
    }
}
exports.Pattern = Pattern;
// declare global {
//   var orcvs: Orcvs;
//   var bang: any
//   // var lerp: any
// }
// globalThis.orcvs = new Orcvs;
// globalThis.bang = (pattern: string, fn: any) => { 
//   orcvs.bang(pattern, fn);
// }
describe('orcvs', () => {
    test.only('lerp', async () => {
        // var lerp = 10
        const ptn = new Pattern('!', function () {
            console.log('bang');
            // @ts-expect-error 
            console.log({ this: this });
            // @ts-expect-error 
            console.log({ lerp: lerp });
            // const value = 1;
            // lerp(value);
        });
        ptn.bang(0);
        // lerp(value, 10);
        // expect(value).toEqual(2);
        // value = lerp('A', 10);
        // expect(value).toEqual(2);        
    });
    // globalThis.lerp = function(value: number) { 
    //   // orcvs.lerp(value);
    //   console.log(this)
    // }
    // function lerp(value: number, tofrom: number, to?: number) {
    //     const start = to ? tofrom : 0; // default to zero and 
    //     const target = to || tofrom;
    //     value = clamp(value + 1, start, target);
    // }
    //   test('bang every', async () => {
    //       const orcvs = new Orcvs();
    //      const mock = jest.fn();
    //       orcvs.bang('!', () => {
    //           console.log('HELLO');
    //           mock();
    //       });
    //       orcvs.tick();
    //       expect(mock).toHaveBeenCalled();
    //       orcvs.tick();
    //       expect(mock).toHaveBeenCalledTimes(2);
    //  });
    //  test('bang every other', async () => {
    //       const orcvs = new Orcvs();
    //       const mock = jest.fn();
    //       orcvs.bang('!.', () => {
    //           mock();
    //       });
    //       orcvs.tick();
    //       orcvs.clock.frame = 1;
    //       orcvs.tick();
    //       orcvs.clock.frame = 2;
    //       expect(mock).toHaveBeenCalled();
    //       orcvs.tick();
    //       orcvs.clock.frame = 3;
    //       expect(mock).toHaveBeenCalledTimes(2);
    //   });
    const lerps = {};
    function lerpa(name, tofrom, to) {
        const start = to ? tofrom : 0; // default to zero and 
        const target = to || tofrom;
        let value = lerps[name] || start;
        value = clamp(value + 1, start, target);
        lerps[name] = value;
        return value;
    }
    // test('bang', async () => {
    //     const orcvs = new Orcvs();
    //     // await orcvs.init();
    //     let channel = orcvs.midi.output?.channels[1];
    //     // channel?.playNote('C3', {attack: 0.5, duration: 500} )
    //     // channel?.sendNoteOn('C3', {attack: 0.5} )
    //     // await new Promise((r) => setTimeout(r, 250));
    //     // channel?.sendNoteOff('C3');
    //     // orcvs.bang('!.......', () => {
    //     //     console.log('HELLO');
    //     //     orcvs.play(1, 3, 'C', 0.5, 1);
    //     //     // orcvs.play(1, 2, 'E', 0.5, 0.5);
    //     // });
    //     // for (let f = 0; f < 2; f++) {
    //     //     orcvs.run();
    //     //     orcvs.clock.tick();
    //     // }
    //     // await new Promise((r) => setTimeout(r, 15000));
    //     await new Promise((r) => setTimeout(r, 5000));
    //     await orcvs.stop();
    //     await new Promise((r) => setTimeout(r, 5000));
    // });
});
//# sourceMappingURL=orcvs.test.js.map